package jaicore.search.algorithms.standard.uncertainty.explorationexploitationsearch;

import java.util.Collection;
import java.util.Iterator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import jaicore.search.algorithms.standard.uncertainty.ISolutionDistanceMetric;
import jaicore.search.structure.core.Node;
import jaicore.search.structure.core.OpenCollection;
import jaicore.search.structure.core.PriorityQueueOpen;

public class UncertaintyExplorationOpenSelection<T, V extends Comparable<V>> implements OpenCollection<Node<T, V>> {

	private static final Logger logger = LoggerFactory.getLogger(UncertaintyExplorationOpenSelection.class);
	
	private final OpenCollection<Node<T, V>> primaryOpen;
	private final PriorityQueueOpen<Node<T, V>> secondaryOpen = new PriorityQueueOpen<>();
	private final ISolutionDistanceMetric<T> solutionDistanceMetric;
	private double minimumSolutionDistanceForExploration;
	private int explorationPhaseLength = 10;
	private int exploitationPhaseLength = 50;
	private int selectedNodes = 0;
	private int exploredNodes = 0;
	private boolean exploring = false;

	public UncertaintyExplorationOpenSelection(int explorationPhaseLength, int exploitationPhaseLength, ISolutionDistanceMetric<T> solutionDistanceMetric, double minimumSolutionDistanceForExploration) {
		super();
		this.primaryOpen = new PriorityQueueOpen<>();
		this.explorationPhaseLength = explorationPhaseLength;
		this.exploitationPhaseLength = exploitationPhaseLength;
		this.solutionDistanceMetric = solutionDistanceMetric;
		this.minimumSolutionDistanceForExploration = minimumSolutionDistanceForExploration;
	}

	@Override
	public Node<T, V> peek() {
		if (!exploring) {
			selectedNodes++;
			if (selectedNodes % exploitationPhaseLength != 0) {
				logger.info("Exploiting ...");
				return primaryOpen.peek();
			}

			/* now chose particular node for expansion */
			T currentlyBestCandidate = primaryOpen.peek().getPoint();
			Node<T, V> nodeToBeExplored = primaryOpen.stream().max((n1, n2) -> {
				try {
					double solutionDistance1 = solutionDistanceMetric.calculateSolutionDistance(n1.getPoint(), currentlyBestCandidate);
					double solutionDistance2 = solutionDistanceMetric.calculateSolutionDistance(n2.getPoint(), currentlyBestCandidate);
					boolean exploreCandidate1 = solutionDistance1 >= minimumSolutionDistanceForExploration;
					boolean exploreCandidate2 = solutionDistance2 >= minimumSolutionDistanceForExploration;
					if (exploreCandidate1 && exploreCandidate2) {
						Double u1 = (Double)n1.getAnnotation("uncertainty");
						Double u2 = (Double)n2.getAnnotation("uncertainty");
						if (u1 != null && u2 != null) {
							return Double.compare(u1, u2);
						} else {
							return 0;
						}
					} else {
						if (exploreCandidate1) {
							return -1;
						} else if (exploreCandidate2) {
							return 1;
						} else {
							Double u1 = (Double)n1.getAnnotation("uncertainty");
							Double u2 = (Double)n2.getAnnotation("uncertainty");
							if (u1 != null && u2 != null) {
								return Double.compare(u1, u2);
							} else {
								return 0;
							}							
						}
					}
				} catch (Exception e) {
					logger.error(e.getMessage());
				}
				return 0;
			}).orElse(null);

			/* enable exploration with the node selected by the explorer evaluator */
			try {
				logger.info("Entering exploration phase under {} with uncertainty: {}", nodeToBeExplored, nodeToBeExplored.getAnnotation("uncertainty"));
			} catch (Exception e) {
				logger.error(e.getMessage());
			}
			exploring = true;
			exploredNodes = 0;
			primaryOpen.remove(nodeToBeExplored);
			secondaryOpen.clear();
			secondaryOpen.add(nodeToBeExplored);
			return nodeToBeExplored;
		} else {
			exploredNodes++;
			if (exploredNodes > explorationPhaseLength || secondaryOpen.isEmpty()) {
				exploring = false;
				primaryOpen.addAll(secondaryOpen);
				secondaryOpen.clear();
				logger.info("Entering exploitation phase");
				return primaryOpen.peek();
			}
			Node<T, V> exploredNode = secondaryOpen.peek();
			logger.info("Exploring at node with uncertainty " + exploredNode.getAnnotation("uncertainty") + " ...");
			return secondaryOpen.peek();
		}
	}

	@Override
	public boolean add(Node<T, V> node) {
		assert !contains(node) : "Node " + node + " is already there!";
		if (exploring) {
			return secondaryOpen.add(node);
		} else
			return primaryOpen.add(node);
	}

	@Override
	public boolean remove(Object node) {
		assert !(primaryOpen.contains(node) && secondaryOpen.contains(node)) : "A node (" + node + ") that is to be removed is in BOTH open lists!";
		if (exploring) {
			return secondaryOpen.remove(node) || primaryOpen.remove(node);
		} else {
			return primaryOpen.remove(node) || secondaryOpen.remove(node);
		}
	}

	@Override
	public boolean addAll(Collection<? extends Node<T, V>> arg0) {
		if (exploring) {
			return secondaryOpen.addAll(arg0);
		} else
			return primaryOpen.addAll(arg0);
	}

	@Override
	public void clear() {
		primaryOpen.clear();
		secondaryOpen.clear();
	}

	@Override
	public boolean contains(Object arg0) {
		return primaryOpen.contains(arg0) || secondaryOpen.contains(arg0);
	}

	@Override
	public boolean containsAll(Collection<?> arg0) {
		for (Object o : arg0) {
			if (!contains(o))
				return false;
		}
		return true;
	}

	@Override
	public boolean isEmpty() {
		return primaryOpen.isEmpty() && secondaryOpen.isEmpty();
	}

	@Override
	public Iterator<Node<T, V>> iterator() {
		return null;
	}

	@Override
	public boolean removeAll(Collection<?> arg0) {
		return primaryOpen.removeAll(arg0) && secondaryOpen.removeAll(arg0);
	}

	@Override
	public boolean retainAll(Collection<?> arg0) {
		return primaryOpen.retainAll(arg0) && secondaryOpen.retainAll(arg0);
	}

	@Override
	public int size() {
		return primaryOpen.size() + secondaryOpen.size();
	}

	@Override
	public Object[] toArray() {
		return primaryOpen.toArray();
	}

	@SuppressWarnings("unchecked")
	@Override
	public <X> X[] toArray(X[] arg0) {
		return (X[]) primaryOpen.toArray();
	}

}
